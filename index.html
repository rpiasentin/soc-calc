<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>OCV → SoC Calculator with Overlay</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 0; }
    /* container must be block so canvas top/left === image top/left */
    #container { position: relative; display: block; }
    #chart     { display: block; width: 100%; height: auto; }
    #overlay   { position: absolute; top: 0; left: 0; pointer-events: none; }
    #controls  { padding: 1em; }
    input      { width: 80px; }
    button     { margin-left: 8px; }
  </style>
</head>
<body>

  <!-- 1) Image + canvas at very top -->
  <div id="container">
    <img id="chart" src="chart.png" alt="OCV vs SoC Curve">
    <canvas id="overlay"></canvas>
  </div>

  <!-- 2) Controls below -->
  <div id="controls">
    <h1>OCV → SoC Calculator</h1>
    <label>
      Measured Voltage (V):
      <input id="volt" type="number" step="0.001" value="2.02" disabled>
    </label>
    <button id="calc" disabled>Calculate &amp; Plot</button>
    <p>Estimated SoC: <strong><span id="out">--</span>%</strong></p>
  </div>

  <script>
    // --- Paste your full soc_base and v_base arrays here ---
    const soc_base    = [/* 0.00, 0.50, …, 100.00 */];
    const v_base      = [/* 1.937599053950, 1.940221732050, …, 2.170000000000 */];

    // Build a 0.01% resolution lookup
    const s_full = Array.from({ length: 10001 }, (_, i) => i * 0.01);
    const v_full = s_full.map(sf => {
      let lo = 0, hi = soc_base.length - 1;
      while (hi - lo > 1) {
        const mid = (lo + hi) >> 1;
        if (soc_base[mid] > sf) hi = mid;
        else lo = mid;
      }
      const [s0, s1] = [soc_base[lo], soc_base[hi]];
      const [v0, v1] = [v_base[lo],   v_base[hi]];
      const t = (sf - s0) / (s1 - s0);
      return v0 + (v1 - v0) * t;
    });

    function invertSoC(v) {
      if (v <= v_full[0]) return 0.00;
      if (v >= v_full[v_full.length - 1]) return 100.00;
      let lo = 0, hi = v_full.length - 1;
      while (hi - lo > 1) {
        const mid = (lo + hi) >> 1;
        if (v_full[mid] > v) hi = mid;
        else lo = mid;
      }
      const [v0, v1] = [v_full[lo], v_full[hi]];
      const [s0, s1] = [s_full[lo], s_full[hi]];
      return s0 + (v - v0) * (s1 - s0) / (v1 - v0);
    }

    // Pixel → image mapping (your axes)
    const X0 = 94,  X1 = 865;
    const Y0 = 137, Y1 = 595;
    const VTOP = 2.17, VBOT = 1.82;

    const img    = document.getElementById('chart');
    const canvas = document.getElementById('overlay');
    const ctx    = canvas.getContext('2d');

    function resizeCanvas() {
      const w = img.clientWidth, h = img.clientHeight;
      canvas.style.width  = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width  = w;
      canvas.height = h;
    }

    function plotPoint(soc, v) {
      resizeCanvas();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Map to natural‐px then scale
      const x_nat = X0 + (soc / 100) * (X1 - X0);
      const y_nat = Y0 + (VTOP - v) / (VTOP - VBOT) * (Y1 - Y0);
      const sx = canvas.width  / img.naturalWidth;
      const sy = canvas.height / img.naturalHeight;

      ctx.beginPath();
      ctx.arc(x_nat * sx, y_nat * sy, 6, 0, 2 * Math.PI);
      ctx.fillStyle = 'red'; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = 'white'; ctx.stroke();
    }

    img.onload = () => {
      // Enable UI
      document.getElementById('volt').disabled = false;
      document.getElementById('calc').disabled = false;
      // Initial plot
      const v0 = parseFloat(document.getElementById('volt').value);
      const s0 = invertSoC(v0);
      document.getElementById('out').textContent = s0.toFixed(2);
      plotPoint(s0, v0);
    };
    // In case image is already in cache
    if (img.complete) img.onload();

    document.getElementById('calc').onclick = () => {
      const v = parseFloat(document.getElementById('volt').value);
      const s = invertSoC(v);
      document.getElementById('out').textContent = s.toFixed(2);
      plotPoint(s, v);
    };
  </script>
</body>
</html>